(** This file is intended to be used as [Require] by every file
    generated by CFMLC. *)

Set Implicit Arguments.
From TLC Require Import LibTactics.
From CFML Require Import WPBuiltin SepBase SepLifted.


(* ********************************************************************** *)
(** ** Additional definitions *)

(** Type of representation predicates *)

Definition htype (A a:Type) : Type :=
  A -> a -> hprop.

(********************************************************************)
(* ** Properties of Heap_data *)

(** [Heapdata R] captures the fact that the heap predicate [R]
    captures some real piece of the heap, hence if [x ~> R X]
    and [y ~> R Y] are in disjoint union then [x] and [y] must
    be different values *)

Class Heapdata a A (R:htype A a) := {
  heapdata : forall x y X Y,
    x ~> R X \* y ~> R Y ==>
    x ~> R X \* y ~> R Y \* \[x <> y] }.

Global Instance Heapdata_hheader :
  Heapdata hheader.
Proof.
  constructor. intros x y X Y.
  tests : (x=y).
  { unfold hheader. repeat rewrite repr_eq.
    xchange* hstar_hsingle_same_loc. }
  { xsimpl*. }
Qed.

Lemma Heapdata_intro : forall a A (R:htype A a),
  (forall x X1 X2, x ~> R X1 \* x ~> R X2 ==> \[False]) ->
  Heapdata R.
Proof using.
  introv H. constructors. intros x y X Y. tests: (x = y).
  { xchanges (>> H y X Y). } { xsimpl*. }
Qed.

Lemma Heapdata_false : forall a A (R:htype A a) x X1 X2,
  Heapdata R ->
  x ~> R X1 \* x ~> R X2 ==> \[False].
Proof using. introv H. xchanges (>> heapdata x x X1 X2). Qed.

(* ********************************************************************** *)

(** CFML generates characteristic formulae, which are axioms that corresponds
    to the WP of the soure code. In the future, the plan is to have CFML also
    generate the corresponding code in the deep embedding (Semantics.v) and
    generate proofs that the characteristic formulae are correct, i.e. that
    they are derivable from the WPs that are generated inside Coq by the
    wpgen function from WPLifted.v.

    CFML translates every OCaml type into a corresponding Coq type. To
    translate OCaml type variables, CFML uses Coq type variables, however
    it contraints them to satisfy the [Enc] typeclass. Doing so is necessary
    to allow, eventually, proving the characteristic formulae correct.

    For the set up to work smoothly, all types manipulated by CFML need to be
    "encodable", i.e. to satisfy the typeclass [Enc], which captures the fact
    that a type corresponds to data that can be encoded into the deep embedding.
    In the future, we will generate for every OCaml type a concrete encoding
    function, giving evidence that the types introduced all satisfy the typeclass
    [Enc]. In the meantime, we simply take an axiom asserting that all types
    are encodable, as we do not yet have all the tooling set up for generating
    all the necessary definitions and proofs.

    Assuming all types to be encodable is somewhat similar to what the older
    version of CFML was doing: it was not constraining the type variables at
    all. Reflecting OCaml type variables by unconstrained Coq variables was
    carefully justified in Section 6.4 from Arthur CharguÃ©raud's PhD thesis. *)

Module Use_Enc_any.
Parameter Enc_any : forall A, Enc A.
End Use_Enc_any.

(* ********************************************************************** *)
(** ** Tooling for registering a CF with each toplevel definition *)

(** Registration of CF axioms for use by [xwp] tactic.
    CFMLC generates lines of the form
[[
    Hint Extern 1 (RegisterCF myfunc) => WPHeader_Provide myfunc__cf.
]]

   Then the [xwp] tactic can call [ltac_database_get database_cf myfunc]
   to retrieve [myfunc__cf] as hypothesis as head of the goal. *)

Declare Scope wptactics_scope.
Open Scope wptactics_scope.

Definition database_cf := True.

Notation "'WPHeader_Register_CF' T" := (ltac_database (boxer database_cf) (boxer T) _)
  (at level 69, T at level 0) : wptactics_scope.

Ltac WPHeader_Provide T := Provide T.


(* ********************************************************************** *)
(** ** Tooling for registering a Spec with each toplevel definition *)

Definition database_spec := True. (* TODO: check it needs to be here *)
