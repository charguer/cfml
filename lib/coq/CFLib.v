(** This file is intended to be used as [Require] by every file
    that contains proofs with respect to characteristic formulae
    generated by CFMLC. *)

Require Export LibTactics LibCore LibListZ LibInt LibSet LibMap.
Require Export CFHeader (* CFBuiltin TODO? *) CFTactics.
(* Open Scope heap_scope. *)




(* ---------------------------------------------------------------------- *)
(** Additional notation for more concise specifications at scale. *)

(** The following notation is only used for parsing. *)

(** [\[= v]] is short for [fun x => \[x = v]].
    It typically appears in a postcondition, after then [POST] keyword. *)

Notation "\[= v ]" := (fun x => \[x = v])
  (at level 0, only parsing) : triple_scope.

(** [H1 ==+> H2] is short for [H1 ==> (H1 \* H2)].
    Typical usage is for extracting a pure fact from a heap predicate. *)

Notation "H1 ==+> H2" := (pred_incl P%hprop (heap_is_star H1 H2))
  (at level 55, only parsing) : triple_scope.

(** [TRIPLE t PRE H POSTUNIT H2] is short for [POST (fun (_:unit) => H2)] *)

Notation "'TRIPLE' t 'PRE' H 'POSTUNIT' H2" :=
  (Triple t H (fun (_:unit) => H2))
  (at level 39, t at level 0, only parsing,
  format "'[v' 'TRIPLE'  t  '/' 'PRE'  H  '/' 'POSTUNIT'  H2 ']'") : triple_scope.

(** [TRIPLE t PRE H RET X POST H2] is short for [POST (fun x => H2)]. *)

Notation "'TRIPLE' t 'PRE' H1 'RET' v 'POST' H2" :=
  (Triple t H1 (fun r => \[r = v] \* H2))
  (at level 39, t at level 0, only parsing,
   format "'[v' 'TRIPLE'  t  '/' 'PRE'  H1  '/'  'RET'  v  '/'  'POST'  H2 ']'") : triple_scope.

(** [TRIPLE t INV H POST Q] is short for [TRIPLE T PRE H POST (Q \*+ H)] *)

Notation "'TRIPLE' T 'INV' H 'POST' Q" :=
  (Triple t H%hprop (Q \*+ H%hprop))
  (at level 69, only parsing,
   format "'[v' 'TRIPLE'  t '/' '[' 'INV'  H  ']'  '/' '[' 'POST'  Q  ']'  ']'")
   : triple_scope.

(** [TRIPLE t PRE H1 INV H2 POST Q] is short for [TRIPLE T PRE (H1 \* H2) POST (Q \*+ H2)] *)

Notation "'TRIPLE' T 'PRE' H1 'INV'' H2 'POST' Q" :=
  (Triple t (H1 \* H2) (Q \*+ H2%hprop))
  (at level 69, only parsing,
   format "'[v' 'TRIPLE'  t '/' '[' 'PRE''  H1  ']'  '/' '[' 'INV''  H2  ']'  '/' '[' 'POST'  Q  ']'  ']'")
   : triple_scope.

(** Additional combination of [INV] with [POSTUNIT] and [RET] *)

Notation "'TRIPLE' T 'INV' H1 'POSTUNIT' H2" :=
  (Triple t H1%hprop (fun (_:unit) => H1 \* H2%hprop))
  (at level 69, only parsing,
   format "'[v' 'TRIPLE'  t '/' '[' 'INV'  H1 ']'  '/' '[' 'POSTUNIT'  H2  ']'  ']'")
   : triple_scope.

Notation "'TRIPLE' T 'PRE' H1 'INV'' H2 'POSTUNIT' H3" :=
  (Triple t (H1 \* H2) (fun (_:unit) => H3 \* H2%hprop))
  (at level 69, only parsing,
   format "'[v' 'TRIPLE'  t '/' '[' 'PRE''  H1  ']'  '/' '[' 'INV''  H2  ']'  '/' '[' 'POSTUNIT'  H3  ']'  ']'")
   : triple_scope.

Notation "'TRIPLE' T 'INV' H1 'RET' v 'POST' H2" :=
  (Triple t H1%hprop (fun r => \[r = v] \* H2))
  (at level 69, only parsing,
   format "'[v' 'TRIPLE'  t '/' '[' 'INV'  H1 ']'  '/' '[' 'RET'  v  'POST'  H2  ']'  ']'")
   : triple_scope.

Notation "'TRIPLE' T 'PRE' H1 'INV'' H2 'RET' v 'POST' H3" :=
  (Triple t (H1 \* H2) (fun r => \[r = v] \* H3 \* H2%hprop))
  (at level 69, only parsing,
   format "'[v' 'TRIPLE'  t '/' '[' 'PRE''  H1  ']'  '/' '[' 'INV''  H2  ']'  '/' '[' 'RET'  v  'POST'  H3  ']'  ']'")
   : triple_scope.

