##############################################################################
#
# This Makefile can be used to compile examples.
# Dependencies must be computed first using the "depend" target.
# The computation of all dependencies requires *_ml.v files to be generated
# succesfully.
#
# Usage:
#   alias d='make -f $(CFML)/lib/make/Makefile.dev'
#   d depend && d
#
# Supports building of `vos` and `vok` targets.
#
##############################################################################
# Documentation
#
# $(LIBCOQ) contains:
# - %.v files
# - %.v.d generated files
#
# $(STDLIB) contains:
# - %.ml and %_proof.v files
# - %.cmj and %_ml.v 
# - Stdlib.v wrapper file
#
# $(PWD) contains:
# - %.v auxiliary files
# - %.ml and %_proof.v files
# - %.cmj and %_ml.v generated files
#
# The %.cmj files of $(STDLIB) are compiled before other %.cmj files.
# The other %.cmj files are compiled in order thanks to dependencies in %.depend_ml
# The %_ml.v are generated at the same time as %.cmj.
# The %_proof.v.d can only be computed after the corresponding %_ml.v files exist.
# 
#
# Tip: use -r -d to generate trace
# Tip: find -name List_ml.v -newer .depend_ml 
##############################################################################
# Parameters

# Local parameters can be set in Makefile.dev.local. 
# In particular: CFML, COQBIN, TLC, COQWARNINGS, COQEXTRAFLAGS,
# COQFOLDERNAME, ML, V, V_AUX

-include Makefile.dev.local

PWD := $(shell pwd)

# CFML denotes the path to the root of the CFML folder

ifndef CFML
	CFML := $(shell cd ../.. && pwd)
endif

# COQBIN denotes the path to the Coq binaries (final slash is added if necessary)

ifneq ($(COQBIN),)
	COQBINLASTCHAR=`echo "${$(COQBIN): -1}"`
	ifneq ($(COQBINLASTCHAR),/)
		COQBIN := $(COQBIN)/
	endif
endif

# TLC denotes the path to the TLC library
# Special setting to avoid Makefile.dev.local by developers

ifndef TLC
	ifeq ($(shell echo $$USER),charguer)
		TLC := /home/charguer/tlc/src
	endif
endif
ifdef TLC
	TLC_V := $(wildcard $(TLC)/*.v)
else
	TLC := $(shell $(COQBIN)coqc -where)/user-contrib/TLC
	TLC_V=
endif

# Warning flags for Coq

ifndef COQWARNINGS
	COQWARNINGS=-w -custom-entry-overriden,-notation-overridden,-implicit-core-hint-db,-omega-is-deprecated,-ambiguous-paths,-irrelevant-format-only-parsing
endif

# Other flags for Coq

ifndef COQEXTRAFLAGS
	COQEXTRAFLAGS:=
endif

# All flags for Coq

ifndef COQFLAGS
	COQFLAGS:=$(COQWARNINGS) $(COQEXTRAFLAGS)
endif

# Coq include for the current folder
# - for $(CFML)/examples, we use -R .. EXAMPLE to allow sharing between example folders
# - otherwise by default we use -R . NAME, where NAME denotes the current folder name
# - one can provide a custom value for $(EXAMPLEINCLUDE)

ifndef EXAMPLEINCLUDE
	ifneq ($(filter $(CFML)/examples/%,$(PWD)),)
		EXAMPLEINCLUDE := -R .. EXAMPLE 
		COQPROJECTDEVEXTRA := $(EXAMPLEINCLUDE)
	else
		EXAMPLEINCLUDE  := -R . `basename $(PWD)`
	endif
endif

# ML sources files in current folder

ifndef ML
	ML := $(wildcard *.ml)
endif

# Coq extra files in current folder
# By default, all the local files that are not %_ml.v or %_proof.v

ifndef V_AUX
	V_AUX := $(filter-out %_ml.v %_proof.v,$(wildcard *.v))
endif

# CFMLC flags (e.g. "-debug")

ifndef CFMLC_FLAGS
	CFMLC_FLAGS := 
endif

# The variable $(ML_MAIN) is used to specify which source file is the
# starting point when compiling with ocamlbuild. It can remain undefined
# if there is only one .ml file.

ifndef ML_MAIN
	ML_MAIN := $(ML)
endif

# Options for OCAMLBUILD, by default ignore unused variables

ifndef OCAMLBUILD_FLAGS
	OCAMLBUILD_FLAGS := -cflags -w,-26
endif


############################################################################
# Verbosity control.

# If VERBOSE is defined by the user, then commands are echoed, unless they 
# begin with an explicit @.

ifndef VERBOSE
.SILENT:
endif


##############################################################################
# Folders

LIBCOQ := $(CFML)/lib/coq
STDLIB := $(CFML)/lib/stdlib
GENERATOR := $(CFML)/generator

# COQLIBINCLUDE contains include that are not expected to be in _CoqProject

COQLIBINCLUDE := \
  -Q $(TLC) TLC \
  -Q $(LIBCOQ) CFML \
  -R $(STDLIB) CFML.Stdlib

COQINCLUDE := \
  $(COQLIBINCLUDE) \
  $(EXAMPLEINCLUDE)


##############################################################################
# Binaries.

OCAMLDEP  := $(OCAMLBIN)ocamldep
OCAMLPOST := $(CFML)/lib/make/ocamldep.post

COQC := $(COQBIN)coqc $(COQFLAGS)
COQDEP := $(COQBIN)coqdep -vos

CFMLC := $(CFML)/_build/default/generator/cfmlc.exe

# LATER: could be CFMLC.bc

OCAMLBUILD := \
  ocamlbuild \
    -classic-display -use-ocamlfind \
    -cflags "-g" -lflags "-g" \
	 -X .coq-native


##############################################################################
# Files.

DEPEND := .depend_ml .depend_v

GENERATOR_SRC := $(shell find $(GENERATOR) \( -name '*.ml' -o  -name '*.mli' \) !  -path '$(GENERATOR)/_build/*')

LIBCOQ_V := $(wildcard $(LIBCOQ)/*.v) 

STDLIB_ML := $(wildcard $(STDLIB)/*.ml)
STDLIB_CMJ := $(patsubst %.ml,%.cmj,$(STDLIB_ML))
STDLIB_MLV := $(patsubst %.ml,%_ml.v,$(STDLIB_ML))
STDLIB_PROOFV := $(patsubst %.ml,%_proof.v,$(STDLIB_ML))
STDLIBMAIN := $(STDLIB)/Stdlib.v
STDLIB_V := $(STDLIB_MLV) $(STDLIB_PROOFV) $(STDLIBMAIN)

EXAMPLE_MLV := $(patsubst %.ml,%_ml.v,$(ML))
EXAMPLE_PROOFV := $(patsubst %.ml,%_proof.v,$(ML))
EXAMPLE_V := $(V_AUX) $(EXAMPLE_MLV) $(EXAMPLE_PROOFV)
EXAMPLE_EXE := $(patsubst %.ml,%.native,$(ML_MAIN))
EXAMPLE_MLD := $(patsubst %.ml,%.ml.d,$(ML))

MLV := $(STDLIB_MLV) $(EXAMPLE_MLV)
PROOFV := $(STDLIB_PROOFV) $(EXAMPLE_PROOFV)
OTHERV := $(TLC_V) $(LIBCOQ_V) $(STDLIB)/Stdlib.v $(V_AUX) 

V := $(TLC_V) $(LIBCOQ_V) $(STDLIB_V) $(EXAMPLE_V) 
# Alternative: V := $(MLV) $(PROOFV) $(OTHERV)

VQ := $(patsubst %.v,%.vq,$(V))
VO := $(patsubst %.v,%.vo,$(V))
VOS := $(patsubst %.v,%.vos,$(V))
VOK := $(patsubst %.v,%.vok,$(V))


INTERMEDIATE=%_ml.v $(STDLIB)/%_ml.v
.SECONDARY: $(INTERMEDIATE)
.PRECIOUS: $(INTERMEDIATE)

THISMAKEFILE := $(CFML)/lib/make/Makefile.dev

##############################################################################
# Targets.

# TODO: currently, all *.ml_v files generation must work for targets to be compiled.

.PHONY: all

all: dev ocaml vo

dev: _CoqProjectDev

depend:
	$(MAKE) -f $(THISMAKEFILE) .depend_ml
	$(MAKE) -f $(THISMAKEFILE) mlv
	$(MAKE) -f $(THISMAKEFILE) .depend_v

test:
	echo true

vd: $(VD)
vo: $(VO)
vos: $(VOS)
vok: $(VOK)

ocaml: $(EXAMPLE_EXE)

generator: $(CFMLC)
gen: generator

mlv: $(MLV)
mlvo: $(patsubst %.v,%.vo,$(MLV))

stdlib:  $(patsubst %.v,%.vo,$(STDLIB_V))
stdlibs:  $(patsubst %.v,%.vos,$(STDLIB_V))
stdlibk:  $(patsubst %.v,%.vok,$(STDLIB_V))

coqlib: $(patsubst %.v,%.vo,$(LIBCOQ_V))
coqlibs: $(patsubst %.v,%.vos,$(LIBCOQ_V))
coqlibk: $(patsubst %.v,%.vok,$(LIBCOQ_V))

mlv_show:
	echo $(MLV)
makefile_show:
	echo $(MAKEFILE_LIST)
	echo $(lastword $(MAKEFILE_LIST))


##############################################################################
# Building the generator

$(CFMLC): $(GENERATOR_SRC)
	make -C $(GENERATOR)


############################################################################
# Compiling OCaml code

%.native: %.ml

$(ML_MAIN:.ml=.native):
	$(OCAMLBUILD) $(OCAMLBUILD_FLAGS) $@


############################################################################
# Dependencies

ifeq ($(findstring $(MAKECMDGOALS),ocaml generator dev _CoqProjectDev clean clean_all depend depend_show .depend_v .depend_ml),)
include .depend_ml
endif
ifeq ($(findstring $(MAKECMDGOALS),ocaml generator coqlib coqlibs coqlibk dev _CoqProjectDev clean clean_all depend depend_show .depend_v .depend_ml mlv),)
include .depend_v
endif


# DOCUMENTATION: the dependencies generated by coqdep at the point where the
# files *_ml.v don't exist yet are incomplete, because they lack dependencies
# on those files. We compensate for that by introducing the following dependency
# for %_proof.vo files, and by having .depend_v depend on al $(V) files,
# including $(MLV) files. 

%_proof.vo %_proof.vos %_proof.vok: %_ml.v

.depend_v: $(V)
	@echo "Computing $@"
	$(COQDEP) $(COQINCLUDE) $^ > $@

# DEPRECATED
# .depend_v: $(OTHERV)
# 	@echo "Computing $@"
# 	$(COQDEP) $(COQINCLUDE) $^ > $@
# 
# # .depend_gen_v: .depend_ml $(V)
# # 	@echo "Computing $@"
# 	$(COQDEP) $(COQINCLUDE) $^ > $@

# Hardcoded constraints for $(STDLIBMAIN)

$(patsubst %.v,%.vo,$(STDLIBMAIN)): $(patsubst %.v,%.vo,$(STDLIB_MLV))
$(patsubst %.v,%.vos,$(STDLIBMAIN)) $(patsubst %.v,%.vok,$(STDLIBMAIN)): $(patsubst %.v,%.vos,$(STDLIB_MLV))


# DEPRECATED
# For some reason, coqdep generates absolute paths to files in the local folder,
# and that deeply confuses make, which then considers $(PWD)/foo.vo and foo.vo
# to be distinct files (!). Thus, we need to normalize file paths in $(PWD).
# PWD_SED_PATTERN:=$(shell pwd | sed 's;/;\\/;g')\/
# | sed 's/$(PWD_SED_PATTERN)//g'


############################################################################
# Dependencies between CMJ files

# As described by the recipe below, including the dependency files $(D)
# adds dependencies of the form:
#   A.cmj: B.cmj
# whenever module A depends on module B.

# We use ocamldep to find out which files A depends upon.

# ocamldep must be passed appropriate -I flags, as it searches the file system
# to find where each module is stored. We assume that these flags are given by
# $(OCAML_INCLUDE).

OCAML_INCLUDE := -I .

# By using ocamldep in this way, we obtain dependencies that mention absolute
# path names, as desired. We cannot use ocamldep -modules because it does not
# perform this search and does not produce absolute path names.

# ocamldep does not reliably print absolute path names -- its output depends
# on the current directory! it omits the absolute path if it coincides with
# the current directory. So, we change the current directory to /tmp before
# invoking ocamldep.

# ocamldep produces the following dependencies:
#   A.cmo: B.cmi (or B.cmo, depending on the existence of B.mli, I think)
#   A.cmx: B.cmx (or B.cmi, depending on obscure criteria)
# We keep only the second line and replace both .cmx and .cmi with .cmj in it.

# ocamldep sometimes produces a dependency A.cmx: A.cmi (not sure why).
# This leads us to produce a circular dependency A.cmj: A.cmj.
# The script $(OCAMLPOST) filters it out.

SED := $(shell if command -v gsed >/dev/null ; then echo gsed ; else echo sed ; fi)

.depend_ml: $(ML)
	@echo "Computing $@"
	($(OCAMLDEP) -one-line $(OCAML_INCLUDE) $^) \
	  | grep cmx \
	  | $(SED) -e "s/\\.cm\\(x\\|i\\)/\\.cmj/g" \
	  > $@

# TODO: MAKE OCAMLPOST WORK MULTILINE
# DEPRECATED
# 	  | xargs -L1 $(OCAMLPOST) \



##############################################################################
# Building the Stdlib files 

$(STDLIB)/Pervasives_ml.v $(STDLIB)/Pervasives.cmj: $(STDLIB)/Pervasives.ml $(CFMLC)
	@echo "Generating stdlib characteristic formulae for `basename $<`..."
	$(CFMLC) -nostdlib -nopervasives -I $(STDLIB) $< || (rm -f $@; exit 1)

$(STDLIB)/%_ml.v $(STDLIB)/%.cmj: $(STDLIB)/%.ml $(STDLIB)/Pervasives.cmj $(CFMLC)
	@echo "Generating stdlib characteristic formulae for `basename $<`..."
	$(CFMLC) -nostdlib -I $(STDLIB) $< || (rm -f $@; exit 1)


##############################################################################
# Generating %.cmj and %_ml.v.

# Note: we must delete the .cmj file if the construction of the _ml.v file
# has failed. (Maybe the generator itself should take care of that!)
# 	@echo "Generating characteristic formulae for `basename $<`..."

%_ml.v: %.cmj
	echo > /dev/null

%.cmj: %.ml $(STDLIB_CMJ) $(CFMLC)
	@echo "Generating $*_ml.v"
	$(CFMLC) -I $(STDLIB) -I . $< || (rm -f $@; exit 1)


############################################################################
# Coq rules.

%.vo: %.v
	@echo "Compiling $<"
	$(COQC) $(COQINCLUDE) $<

%.vos: %.v
	@echo "Digesting $<"
	$(COQC) $(COQINCLUDE) -vos $<

%.vok: %.v
	@echo "Checking $<"
	$(COQC) $(COQINCLUDE) -vok $<


##############################################################################
# Build custom _CoqProject

_CoqProject: .FORCE
	@echo $(COQINCLUDE) $(addprefix -arg ,$(COQWARNINGS)) > $@

_CoqProjectDev: .FORCE
	@echo $(COQLIBINCLUDE) $(COQPROJECTDEVEXTRA) > $@

.FORCE:


##############################################################################
# Cleanup.

clean:
	rm -rf $(DEPEND)
	rm -rf *.cmj *_ml.v _output *.vo *.vos *.vok *.glob *.native 

clean_all: clean
	make -C $(STDLIB) clean
	make -C $(LIBCOQ) clean
	make -C $(GENERATOR) clean

clean_vo: clean
	cd $(STDLIB); rm *.vo
	cd $(LIBCOQ); rm *.vo

clean_vos: clean
	cd $(STDLIB); rm *.vos *.vok
	cd $(LIBCOQ); rm *.vos *.vok
