##############################################################################
#
# This Makefile can be used to compile examples.
# Dependencies must be computed first using the "depend" target.
# The computation of all dependencies requires *_ml.v files to be generated
# succesfully.
#
# Usage:
#   alias d='make -f $(CFML)/lib/make/Makefile.dev'
#   d depend && d
#
# Supports building of `vos` and `vok` targets.
#
##############################################################################
# Documentation
#
# $(LIBCOQ) contains:
# - %.v files
# - %.v.d generated files
#
# $(STDLIB) contains:
# - %.ml and %_proof.v files
# - %.cmj and %_ml.v 
# - Stdlib.v wrapper file
#
# $(PWD) contains:
# - %.v auxiliary files
# - %.ml and %_proof.v files
# - %.cmj and %_ml.v generated files
#
# The %.cmj files of $(STDLIB) are compiled before other %.cmj files.
# The other %.cmj files are compiled in order thanks to dependencies in %.depend_ml
# The %_ml.v are generated at the same time as %.cmj.
# The %_proof.v.d can only be computed after the corresponding %_ml.v files exist.
# 
#
# Tip: use -r -d to generate trace
# Tip: find -name List_ml.v -newer .depend_ml 
##############################################################################
# Parameters

# TODO: improve naming convention

# Local parameters can be set in Makefile.dev.local. 
# In particular: CFML, COQBIN, TLC, COQWARNINGS, COQEXTRAFLAGS,
# COQFOLDERNAME, ML, V, V_AUX

-include Makefile.dev.local

PWD := $(shell pwd)

# CFML denotes the path to the root of the CFML folder

ifndef CFML
	CFML := $(shell cd ../.. && pwd)
endif

# COQBIN denotes the path to the Coq binaries (final slash is added if necessary)

ifneq ($(COQBIN),)
	COQBINLASTCHAR=`echo "${$(COQBIN): -1}"`
	ifneq ($(COQBINLASTCHAR),/)
		COQBIN := $(COQBIN)/
	endif
endif

# TLC denotes the path to the TLC library
# Special setting to avoid Makefile.dev.local by developers

ifndef TLC
	ifeq ($(shell echo $$USER),charguer)
		TLC := /home/charguer/tlc/src
		# TLC := /home/charguer/versions/coq-8.13/tlc/src
	endif
endif
ifdef TLC
	TLC_V := $(wildcard $(TLC)/*.v)
else
	TLC := $(shell $(COQBIN)coqc -where)/user-contrib/TLC
	TLC_V=
endif

# Warning flags for Coq

ifndef COQWARNINGS
	COQWARNINGS=-w -custom-entry-overriden,-notation-overridden,-implicit-core-hint-db,-omega-is-deprecated,-ambiguous-paths,-irrelevant-format-only-parsing
endif

# Other flags for Coq

ifndef COQEXTRAFLAGS
	COQEXTRAFLAGS:=
endif

# All flags for Coq

ifndef COQFLAGS
	COQFLAGS:=$(COQWARNINGS) $(COQEXTRAFLAGS)
endif

# Coq include for the current folder
# - for $(CFML)/examples, we use -R .. EXAMPLE to allow sharing between example folders
# - otherwise by default we use -R . NAME, where NAME denotes the current folder name
# - one can provide a custom value for $(EXAMPLEINCLUDE)
# - the special value EMPTY indicates that $(EXAMPLEINCLUDE) should be empty

ifdef ARG_EXAMPLEINCLUDE
	EXAMPLEINCLUDE := $(ARG_EXAMPLEINCLUDE)
endif
ifndef EXAMPLEINCLUDE
	ifneq ($(filter $(abspath $(CFML))/examples/%,$(PWD)),)
		EXAMPLEINCLUDE := -R .. EXAMPLES
		COQPROJECTDEVEXTRA := $(EXAMPLEINCLUDE)
	else
		EXAMPLEINCLUDE  := -R . `basename $(PWD)`
	endif
else
	ARG_EXAMPLEINCLUDE := $(EXAMPLEINCLUDE)
	ifeq ($(EXAMPLEINCLUDE),EMPTY)
		EXAMPLEINCLUDE :=
	endif
endif


# Ocamldep include folder.

ifndef OCAMLINCLUDE
	OCAMLINCLUDE := -I .
endif


# ML sources files in current folder
# - the special value EMPTY indicates that $(ML) should be empty

ifdef ARG_ML
	ML := $(ARG_ML)
endif
ifndef ML
	ML := $(wildcard *.ml)
else
	ARG_ML := $(ML)
	ifeq ($(ML),EMPTY)
		ML :=
	endif
endif

# Coq extra files in current folder
# By default, all the local files that are not %_ml.v or %_proof.v
# the special value EMPTY indicates that $(V_AUX) should be empty

ifdef ARG_V_AUX
	V_AUX := $(ARG_V_AUX)
endif
ifndef V_AUX
	V_AUX := $(filter-out %_ml.v %_proof.v,$(wildcard *.v))
else
	ARG_V_AUX := $(V_AUX)
	ifeq ($(V_AUX),EMPTY)
		V_AUX :=
	endif
endif


# CFMLC flags (e.g. "-debug")

ifndef CFMLC_FLAGS
	CFMLC_FLAGS := 
endif

# The variable $(ML_MAIN) is used to specify which source file is the
# starting point when compiling with ocamlbuild. It can remain undefined
# if there is only one .ml file.

ifndef ML_MAIN
	ML_MAIN := $(ML)
endif

# Options for OCAMLBUILD, by default ignore unused variables

ifndef OCAMLBUILD_FLAGS
	OCAMLBUILD_FLAGS := -cflags -w,-26
endif

# Files to open in IDE
# By default, all the local proof files, sorted by last modification date

ifndef OPENINIDE
	OPENINIDE := $(shell ls -t *.v 2> /dev/null || echo "")
endif

# Options for CoqIDE. By default, disable parallel progress

ifndef COQIDEOPTIONS
	COQIDEOPTIONS := -async-proofs off -async-proofs-command-error-resilience off
endif


############################################################################
# Verbosity control.

# If VERBOSE is defined by the user, then commands are echoed, unless they 
# begin with an explicit @.

ifndef VERBOSE
.SILENT:
endif


##############################################################################
# Folders

GENERATOR := $(CFML)/generator
LIBCOQ := $(CFML)/lib/coq
STDLIB := $(CFML)/lib/stdlib
EXAMPLES := $(CFML)/examples

# COQLIBINCLUDE contains include that are not expected to be in _CoqProject

COQLIBINCLUDE := \
  -Q $(TLC) TLC \
  -Q $(LIBCOQ) CFML \
  -R $(STDLIB) CFML.Stdlib

COQINCLUDE := \
  $(COQLIBINCLUDE) \
  $(EXAMPLEINCLUDE)

# We recognize $(LIBCOQ) to avoid compiling $(STDLIB) when we type 'make' in the
# $(LIBCOQ) folder.

ifeq ($(PWD),$(abspath $(LIBCOQ)))
	CURRENTFOLDERISLIBCOQ := true
else
	CURRENTFOLDERISLIBCOQ := false
	LIBCOQ := $(abspath $(LIBCOQ))
endif

# We recognize $(STDLIB) to set it as "./" if applicable, for the specific compilation 
# rules of $(STDLIB) to apply when we type 'make' in that folder

ifeq ($(PWD),$(abspath $(STDLIB)))
	CURRENTFOLDERISSTDLIB := true
	STDLIB := ./
else
	CURRENTFOLDERISSTDLIB := false
	STDLIB := $(abspath $(STDLIB))
endif

# We recognize $(EXAMPLES) for efficiently compiling all examples at once.

ifeq ($(PWD),$(abspath $(EXAMPLES)))
	CURRENTFOLDERISEXAMPLE := true
else
	CURRENTFOLDERISEXAMPLE := false
endif


##############################################################################
# Binaries.

OCAMLDEP  := $(OCAMLBIN)ocamldep
OCAMLPOST := $(CFML)/lib/make/ocamldep.post

COQC := $(COQBIN)coqc $(COQFLAGS)
COQIDE := $(COQBIN)coqide $(COQFLAGS)
COQDEP := $(COQBIN)coqdep -vos

# OPTIONAL saving of error in a file, to open in the ide the error file first
SHELL := /bin/bash
COQERROR := .coq_error
#COQSAVERROR := 2> >(tee $(COQERROR))
COQSAVERROR := | tee $(COQERROR)
# 1> >(tee $(COQERROR))

CFMLC := $(CFML)/_build/default/generator/cfmlc.exe

# LATER: could be CFMLC.bc

OCAMLBUILD := \
  ocamlbuild \
    -classic-display -use-ocamlfind \
    -cflags "-g" -lflags "-g" \
	 -X .coq-native


##############################################################################
# Files.

DEPEND := .depend_libcoq .depend_ml .depend_v 

GENERATOR_SRC := $(shell find $(GENERATOR) \( -name '*.ml' -o  -name '*.mli' \) !  -path '$(GENERATOR)/_build/*')

LIBCOQ_V := $(wildcard $(LIBCOQ)/*.v) 

STDLIB_ML := $(wildcard $(STDLIB)/*.ml)
STDLIB_CMJ := $(patsubst %.ml,%.cmj,$(STDLIB_ML))
STDLIB_MLV := $(patsubst %.ml,%_ml.v,$(STDLIB_ML))
STDLIB_PROOFV := $(patsubst %.ml,%_proof.v,$(STDLIB_ML))
STDLIBMAIN := $(STDLIB)/Stdlib.v
STDLIB_V := $(STDLIB_MLV) $(STDLIB_PROOFV) $(STDLIBMAIN)

EXAMPLE_MLV := $(patsubst %.ml,%_ml.v,$(ML))
EXAMPLE_PROOFV := $(patsubst %.ml,%_proof.v,$(ML))
EXAMPLE_V := $(V_AUX) $(EXAMPLE_MLV) $(EXAMPLE_PROOFV)
EXAMPLE_EXE := $(patsubst %.ml,%.native,$(ML_MAIN))
EXAMPLE_MLD := $(patsubst %.ml,%.ml.d,$(ML))

MLV := $(STDLIB_MLV) $(EXAMPLE_MLV)
PROOFV := $(STDLIB_PROOFV) $(EXAMPLE_PROOFV)
OTHERV := $(TLC_V) $(LIBCOQ_V) $(STDLIB)/Stdlib.v $(V_AUX) 

ifeq ($(CURRENTFOLDERISLIBCOQ),true)
	V := $(TLC_V) $(LIBCOQ_V)
else
	V := $(TLC_V) $(LIBCOQ_V) $(STDLIB_V) $(EXAMPLE_V)
endif


# Alternative: V := $(MLV) $(PROOFV) $(OTHERV)

VQ := $(patsubst %.v,%.vq,$(V))
VO := $(patsubst %.v,%.vo,$(V))
VOS := $(patsubst %.v,%.vos,$(V))
VOK := $(patsubst %.v,%.vok,$(V))


INTERMEDIATE=%_ml.v $(STDLIB)/%_ml.v
.SECONDARY: $(INTERMEDIATE)
.PRECIOUS: $(INTERMEDIATE)

THISMAKEFILE := $(CFML)/lib/make/Makefile.dev

##############################################################################
# Targets.

# TODO: currently, all *.ml_v files generation must work for targets to be compiled.

.PHONY: all

all: ocaml vo

# dev: _CoqProjectDev

# It it important to export parameters to recursive calls for "make depend"
# NOT EXPORTED BECAUSE OF THE 'EMPTY' TWEAK export ML V_AUX EXAMPLEINCLUDE
export CFML
export OCAMLINCLUDE
export COQBIN 
export TLC 
export COQWARNINGS
export COQEXTRAFLAGS
export COQFLAGS
export CFMLC_FLAGS
export ARG_V_AUX
export ARG_ML
export ARG_EXAMPLEINCLUDE


depend: _CoqProject
	$(MAKE) -f $(THISMAKEFILE) .depend_libcoq
	$(MAKE) -f $(THISMAKEFILE) .depend_ml
	$(MAKE) -f $(THISMAKEFILE) mlv
	$(MAKE) -f $(THISMAKEFILE) .depend_v

test:
	echo true

vd: $(VD)
vo: $(VO)
vos: $(VOS)
vok: $(VOK)

ocaml: $(EXAMPLE_EXE)

generator: $(CFMLC)
gen: generator

mlv: $(MLV)
mlvo: $(patsubst %.v,%.vo,$(MLV))

stdlib:  $(patsubst %.v,%.vo,$(STDLIB_V))
stdlibs:  $(patsubst %.v,%.vos,$(STDLIB_V))
stdlibk:  $(patsubst %.v,%.vok,$(STDLIB_V))

libcoq: $(patsubst %.v,%.vo,$(LIBCOQ_V))
libcoqs: $(patsubst %.v,%.vos,$(LIBCOQ_V))
libcoqk: $(patsubst %.v,%.vok,$(LIBCOQ_V))

mlv_show:
	echo $(MLV)
makefile_show:
	echo $(MAKEFILE_LIST)
	echo $(lastword $(MAKEFILE_LIST))


##############################################################################
# Building the generator

$(CFMLC): $(GENERATOR_SRC)
	make -C $(GENERATOR)


############################################################################
# Compiling OCaml code

%.native: %.ml

$(ML_MAIN:.ml=.native):
	$(OCAMLBUILD) $(OCAMLBUILD_FLAGS) $@


############################################################################
# Dependencies

AUXGOALS := ocaml generator dev _CoqProjectDev clean clean_all tests
LIBCOQGOALS := libcoq libcoqs libcoqk

# TODO: use an auxiliary function for include_or_error

ifeq ($(findstring $(MAKECMDGOALS),$(AUXGOALS) depend .depend_libcoq .depend_v .depend_ml mlv),)
   ifeq ($(wildcard .depend_libcoq),)
      $(error Missing .depend_libcoq; try 'make depend' first.)
   endif
   include .depend_libcoq
endif

ifndef $(CURRENTFOLDERISLIBCOQ)
   ifeq ($(findstring $(MAKECMDGOALS),$(AUXGOALS) depend .depend_libcoq .depend_v .depend_ml),)
      ifeq ($(wildcard .depend_ml),)
         $(error Missing .depend_ml; try 'make depend' first.)
      endif
   include .depend_ml
   endif

   ifeq ($(findstring $(MAKECMDGOALS),$(AUXGOALS) $(LIBCOQGOALS) depend .depend_v .depend_libcoq .depend_ml mlv),)
      ifeq ($(wildcard .depend_v),)
         $(error Missing .depend_v; try 'make depend' first.)
      endif
   include .depend_v
   endif
endif

# DOCUMENTATION: the dependencies generated by coqdep at the point where the
# files *_ml.v don't exist yet are incomplete, because they lack dependencies
# on those files. We compensate for that by introducing the following dependency
# for %_proof.vo files, and by having .depend_v depend on al $(V) files,
# including $(MLV) files. 

%_proof.vo %_proof.vos %_proof.vok: %_ml.v

.depend_libcoq: $(LIBCOQ_V)
	@echo "Computing $@"
	$(COQDEP) $(COQINCLUDE) $^ > $@

# Below, would not be needed to reinclude LIBCOQ_V
.depend_v: $(V)
	@echo "Computing $@"
	$(COQDEP) $(COQINCLUDE) $^ > $@

# Hardcoded constraints for $(STDLIBMAIN)

$(patsubst %.v,%.vo,$(STDLIBMAIN)): $(patsubst %.v,%.vo,$(STDLIB_MLV))
$(patsubst %.v,%.vos,$(STDLIBMAIN)) $(patsubst %.v,%.vok,$(STDLIBMAIN)): $(patsubst %.v,%.vos,$(STDLIB_MLV))


# DEPRECATED
# For some reason, coqdep generates absolute paths to files in the local folder,
# and that deeply confuses make, which then considers $(PWD)/foo.vo and foo.vo
# to be distinct files (!). Thus, we need to normalize file paths in $(PWD).
# PWD_SED_PATTERN:=$(shell pwd | sed 's;/;\\/;g')\/
# | sed 's/$(PWD_SED_PATTERN)//g'


############################################################################
# Dependencies between CMJ files

# As described by the recipe below, including the dependency files $(D)
# adds dependencies of the form:
#   A.cmj: B.cmj
# whenever module A depends on module B.

# We use ocamldep to find out which files A depends upon.

# By using ocamldep in this way, we obtain dependencies that mention absolute
# path names, as desired. We cannot use ocamldep -modules because it does not
# perform this search and does not produce absolute path names.

# ocamldep does not reliably print absolute path names -- its output depends
# on the current directory! it omits the absolute path if it coincides with
# the current directory. So, we change the current directory to /tmp before
# invoking ocamldep.

# ocamldep produces the following dependencies:
#   A.cmo: B.cmi (or B.cmo, depending on the existence of B.mli, I think)
#   A.cmx: B.cmx (or B.cmi, depending on obscure criteria)
# We keep only the second line and replace both .cmx and .cmi with .cmj in it.

# ocamldep sometimes produces a dependency A.cmx: A.cmi (not sure why).
# This leads us to produce a circular dependency A.cmj: A.cmj.
# The script $(OCAMLPOST) filters it out.

SED := $(shell if command -v gsed >/dev/null ; then echo gsed ; else echo sed ; fi)

.depend_ml: $(ML)
	@echo "Computing $@"
	($(OCAMLDEP) -one-line $(OCAMLINCLUDE) $^) \
	  | grep cmx \
	  | $(SED) -e "s/\\.cm\\(x\\|i\\)/\\.cmj/g" \
	  > $@

# TODO: MAKE OCAMLPOST WORK MULTILINE
# DEPRECATED
# 	  | xargs -L1 $(OCAMLPOST) \



##############################################################################
# Building the Stdlib files 

$(STDLIB)/Pervasives_ml.v $(STDLIB)/Pervasives.cmj: $(STDLIB)/Pervasives.ml $(CFMLC)
	@echo "Generating stdlib $<"
	$(CFMLC) -nostdlib -nopervasives -I $(STDLIB) $< || (rm -f $@; exit 1)

$(STDLIB)/%_ml.v $(STDLIB)/%.cmj: $(STDLIB)/%.ml $(STDLIB)/Pervasives.cmj $(CFMLC)
	@echo "Generating stdlib $<"
	$(CFMLC) -nostdlib -I $(STDLIB) $< || (rm -f $@; exit 1)


##############################################################################
# Generating %.cmj and %_ml.v.

# Note: we must delete the .cmj file if the construction of the _ml.v file
# has failed. (Maybe the generator itself should take care of that!)

%_ml.v: %.cmj
	echo > /dev/null

%.cmj: %.ml $(STDLIB_CMJ) $(CFMLC)
	@echo "Generating $*_ml.v"
	$(CFMLC) -I $(STDLIB) $(OCAMLINCLUDE) -I . $< || (rm -f $@; exit 1)


############################################################################
# Coq rules.

%.vo: %.v
	@echo "Compiling $<" $(COQSAVERROR)
	$(COQC) $(COQINCLUDE) $< 

%.vos: %.v
	@echo "Digesting $<" $(COQSAVERROR)
	$(COQC) $(COQINCLUDE) -vos $<

%.vok: %.v
	@echo "Checking $<" $(COQSAVERROR)
	$(COQC) $(COQINCLUDE) -vok $< 


##############################################################################
# Build custom _CoqProject

_CoqProject: .FORCE
	@echo $(COQINCLUDE) $(addprefix -arg ,$(COQWARNINGS)) > $@

#_CoqProjectDev: .FORCE
#	@echo $(COQLIBINCLUDE) $(COQPROJECTDEVEXTRA) > $@

.FORCE:


##############################################################################
# COQIDE.

ide:
	$(COQIDE) $(COQIDEOPTIONS) $(COQINCLUDE) $(COQPROJECTDEVEXTRA) $(OPENINIDE)

# DEPRECATED COQERRORGET := cat .coq_error | head -n 1 | sed 's/.*File \"\([^\"]*\)\".*/\1/'
COQERRORGET := cat .coq_error | tail -n 1 | sed 's/Compiling \([^"]*\)$$/\1/'

fix:
	$(COQIDE) $(COQIDEOPTIONS) $(COQINCLUDE) $(COQPROJECTDEVEXTRA) `$(COQERRORGET)`




##############################################################################
# Cleanup.

clean::
	rm -rf $(DEPEND)
	rm -rf *.cmj *_ml.v _output *.vo *.vos *.vok *.glob *.native 

clean_all: clean
	make -C $(STDLIB) clean
	make -C $(LIBCOQ) clean
	make -C $(GENERATOR) clean

clean_vo: clean
	cd $(STDLIB); rm *.vo
	cd $(LIBCOQ); rm *.vo

clean_vos: clean
	cd $(STDLIB); rm *.vos *.vok
	cd $(LIBCOQ); rm *.vos *.vok
