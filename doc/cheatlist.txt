
===============
CFML Cheat List
===============

Types
=====

b   bool          boolean value
n   int           idealized integer
l   loc           memory location
x   var           variable

v   val           closed value
t   trm           term
s   state         state                 := fmap loc val

h   heap          piece of state        := state
H   hprop         heap predicate        := heap->Prop
Q                 postcondition         := val->hprop  or  := A->hprop

E   ctx           substitution context  := list (var*val).

Entailment
==========

H1 ==> H2         := forall h, H1 h -> H2 h
Q1 ===> Q2        := forall x, Q1 x ==> Q2 x

Core heap predicates
====================

\[]             hempty                 empty state predicate     := fun h => h = fmap_empty /\ P
\[P]            hpure P                pure heap predicate       := fun h => h = fmap_empty /\ P
\Top            htop                   any heap predicate        := fun h => True
H1 \* H2        hstar H1 H2            separating conjunction    := fun h => exists h1 h2, h = h1 \u h2
                                                                              /\ fmap_disjoint h1 h2
                                                                              /\ H1 h2 /\ H2 h2
\exists x, H    hexists (fun x => H)   existential on hprop      := fun h => exists x, H
p ~~~> v        hsingle p v            singleton heap            := fun h => h = fmap_single p v
p ~~> V         Hsingle p V            lifted singleton heap     := hsingle p (enc V)
p ~> MList L    MList L p              mutable list


Advanced heap predicates
========================

\GC             hgc                    any heap predicate            := exists H, H \* \[haffine H]
\forall x, H    hforall (fun x => H)   universal on hprop            := fun h => forall x, H
H1 \-* H2       hwand H1 h2            magic wand                    := exists H, H \* [H \* H1 ==> H2]
Q1 \--* Q2      qwand Q1 Q2            magic wand on postconditions  := \forall x, Q1 x \-* Q2 x
                hand H1 H2             non-separating conjunction    := fun h => H1 h /\ H2 h


Judgments
=========

red s t s' v     evaluation judgment
hoare t H Q      total correctness Hoare triple, on the whole state
triple t H Q     total correctness SL triple, on a piece of state
Triple t H Q     lifted SL triple
H ==> wp t Q     weakest-precondition style SL triple
H ==> Wp t Q     lifted wp-style SL triple

TRIPLE t PRE H  POST Q                    := Triple t H Q



Wp operators
============

formula        result of wp                := (val->hprop)->hprop
wpgen E t      formula generator
subst x v t    substitution
isubst E t     iterated substitution
structural F   structural formula
mkstruct F     structural wrapper

Lifted wp operators
===================

Formula        result of Wp                := forall A, Enc A -> (A->hprop)->hprop
`F             structural wrapper          := MkStruct F
^F Q           applied formula             := F _ _ Q
Structural F


Syntax for values
=================

'()
n
b
l
VFun 'x := t1
VFix 'f 'x := t1

Syntax for terms
=================

'x
Cstr C x1 xn
If_ t0 Then t1 Else t2
If_ t0 Then t1 End
t1 '; t2
Let 'x := t1 in t2
Let Rec 'f 'x := t1 in t2
Match t With p1 '=> t1 | pn '=> tn End
Fail
'ref t
'! t
t1 ':= t2
'not t
t1 '+ t1
t1 '= t2

Tactics for entailment
======================

xpull
   applies e.g. to:    \exists x, \[x = 3] \* H1 ==> H2
   produces e.g:       forall x, x = 3 -> (H1 ==> H2)

xsimpl
   applies to:     H1 ==> H2
   invokes xpull, then cancel out items on both sides

xsimpl X1 XN
   applies to:     H1 ==> \exists x1 xn, H2
   instantiates x1 := X1 and x2 := X2, then call xsimpl

xchange M
   where M :     H1 ==> H2         or     H1 = H2
   applies to:   H1 \* H3 ==> H4
   produces:     H2 \* H3 ==> H4

xchange <- M
   where M :     H1 = H2
   applies to:   H2 \* H3 ==> H4
   produces:     H1 \* H3 ==> H4

xchanges E
   invokes xchange then xsimpl



Structural tactics for CF
=========================

xwp         TRIPLE (f v) PRE H POST Q
   turns the goal into H ==> wpgen (f v) Q
   useful to establish a specification

xtriple     TRIPLE (f v) PRE H POST Q
   turns the goal into H ==> `App f v Q
   useful to prove a derived specification

xgc         H ==> ^F Q
   turns to H ==> ^F Q \* \GC

xcast

xpost


xframe

Term tactics for CF
===================

xfail       H ==> `Fail Q
   turns the goal to [False]

xval        H ==> (`Val v) Q
   turns the goal to H ==> Q v

xval V
   specifies the value of which v is the encoding

xapp        H ==> `App f v Q
   exploits the registered specification Triple for f

xapp E
   enables to specify the specification triples

xapp_nosubst
   xapp with the substitution that may occur for the reult

xappn
   repeat xapp

xseq        H ==> `Seq F1 F2 Q
   remark: xapp usually applies directly

xlet        H ==> (`Let 'x := F1 F2) Q
   remark: xapp usually applies directly

xif         H ==> (`If b Then F1 Else F2)

TLC tactics
===========

Notation
--------

E: stands for an expression
H: stands for an existing hypothesis
X: stands for a fresh identifier
I: stands for an introduction pattern
R: stands for a definition (a "reference")
__: is a special notation for "wildcard"

foo ;=> I1 .. IN     (same as [foo; intros I1 .. IN])
introv I1 I2 .. IN   (introduction that inputs only the name of hypotheses, not variables)

gen H1 H2 .. HN      (generalizes and clears hypotheses and their dependencies)
clears H1 ... HN     (clears hypotheses and their dependencies)
sets X: E            (defines X as a local definition for E, and replaces occurences of E with X)
sets_eq X: E         (introduces a name X and an equality X = E, and replaces occurences of E with X)
asserts I: E      (asserts statement E as first subgoal, destruct E as I in the second goal)
cuts I: E         (asserts statement E as second subgoal, destruct E as I in the first goal)

Absurd goals
false             (replaces the goal by "False", and try to solve it with contradiction and discriminate)
false E           (shorthand for [false; applys E])
tryfalse          (proves a goal by contradiction or discriminate, or do nothing)

Logical constructs
iff              (tactic to prove an equivalence)
splits           (splits an N-ary conjunction into N goals)
branch N         (selects the N-th branch of a M-ary disjunction)
exists E1 .. EN  (to provide witnesses to an N-ary existential goal, wildcards are supported)

Case analysis and inversion
cases E as I          (case analysis on E, remembering the equality as H)
case_if as I          (case analysis on the first "if" statement in the goal)

inverts H             (inversion followed with substitution of freshly introduced variables)
inverts H as I1..IN   (same as inverts H, but allows to name produced hypotheses)
invert H              (same as inverts H, but leaves hypotheses in the goal)

Induction
inductions_wf X: E H  (applies the well-founded induction principle for a particular well-founded relation)
gen_eq X: E           (generalize X as E and add "X = E" as hypothesis in the goal, useful for induction)

Working with equalities

fequals           (improved implementation of f_equal  calls congruence, and better on tuples)
asserts_rewrite E (rewrites with E and generates E as first subgoal)
cuts_rewrite E    (rewrites with E and generates E as second subgoal)

Simplification and unfolding
simpls        (simpl everywhere in hypotheses and conclusion)
unfolds R     (unfolds the definition of R in hypotheses and conclusion)

Automation
- any tactic name followed with the symbol "~" will call [auto] on all subgoals
- any tactic name followed with the symbol "*" will call [jauto], a variant of [induction eauto]


Below, H stands for the lemma to be instantiated, and the names Ei correspond to the arguments.
Note that wildcards, written "__", can be provided in place of any argument.

lets I: H E1 ... EN                    (instantiates a lemma and names it)
applys H E1 ... EN                     (instantiates a lemma and applies it)
specializes H E1 ... EN                (instantiates an hypothesis H in-place)
forwards I: H E1 .. EN                 (instantiates a lemma on all its arguments, same as "lets I: H E1 .. EN __ __ .. __"
rewrites (>> H E1 ... EN)              (instantiates a lemma, then rewrite with it)

Variant syntax:
   lets I: (>> H E1 ... EN)


applys_eq H i1 .. iN                   (applys H up to equality on arguments of the goal at specified indices)

Clear variables

Any subterm can be of the form rm X, which indicates that the variable X should be cleared after the operation is complete.

