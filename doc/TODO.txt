(* Later: fix the notation for math ops in the display *)


(* ******************************************************* *)
(** ** While loops *)

(* ******************************************************* *)
(** ** For loops *)

(* ******************************************************* *)
(** ** Data constructors *)

(* ******************************************************* *)
(** ** Pattern matching *)

(* ******************************************************* *)
(** ** Terms not in A-normal form *)

(* ******************************************************* *)
(** ** Linear resources *)





--equiv but impractical--
p ~> MList L =
   \exists q, p ~~> q \*
   match L with
   | nil => \[q = null]
   | x::L' => q.head ~~> x \* q.tail ~> MList L'
   end
--

p ~> MListSeg r L =
   match L with
   | nil => \[p = r]
   | x::L' => \exists q, p ~~> q \* q.head ~~> x \* q.tail ~> MListSeg r L'
   end

p ~> MListSeg r nil = \[p = r]

p ~> MListSeg r (x::L') = \exists q, p ~~> q \* q.head ~~> x \* q.tail ~> MListSeg r L'

p ~> MListSeg r (L1++L2) = \exists q, p ~> MListSeg q L1 \* q ~> MListSeq r L2


p ~> MList L = \exists r, p ~> MListSeg r L \* r ~~> null

p ~> MList nil = p ~~> null

p ~> Mist (x::L') = \exists q, p ~~> q \* q.head ~~> x \* q.tail ~> MList L'


let rec mlength p =
   let q = get p in
   if q == null
      then 0
      else 1 + mlength q.tail

let mlength' p =
   let r = ref p in
   let n = ref 0 in
   while !r <> null do
      incr n;
      r := (!r).tail
   done;
   !n

# PRE p ~> MList L
# POST fun r => p ~> MListSeg r L \* r ~~> null
let rec get_back p =
   let q = get p in
   if q == null
      then p
      else get_back q.tail

# PRE p1 ~> MList L1 \* p2 ~> MList L2
# POST p1 ~> MList (L1 ++ L2)
let append p1 p2 =
  let r = get_back p1 in
  r := get p2




=========
=========
=========
LATER
Definition clear :=
    Set 'p'.data ':= ``nil '; (* TODO: ('nil%val)*)

LATER
   xfun_nosubst
   xfun S  // calls wp automatically


LATER: improve to use older technology
   Ltac xsimpl_lr_cancel_eq_repr_post tt :=
     try fequal; try reflexivity.

LATER: inj by default

(* LATER: if hsimpl fails to progress after xapp, warning *)


LATER: admitted in altproofs

=========
=========
=========


https://gitlab.inria.fr/charguer/cfml2_ejcp2019

Framework
=========


# Record
(* TODO:
   Set 'p '. X ':= ('p '.X '+ 1).
   won't parse
*)


# Record
Notation "'New'' `{ f1 := x1 ; f2 := x2 }" :=
   (Wptag (Wpgen_app (trm_apps (trm_val (val_record_init (f1::f2::nil)))) (trms_vals (x1::x2::nil))))
  (at level 0, f1 at level 0, f2 at level 0)
  : wp_scope.


# wp recursively computed for funs

# WPLoops

# WPArray

 ('p ':= '! (tail 'p)) '; (* LATER/ fix priority *)

 (If_ MList.is_empty ('q'.sub) (* LATER/ fix priority *)
   Then 'p ':= null
   Else 'p ':= merge_pairs ('q'.sub) )';
   'x.


Pairing heaps
=============

  (* LATER: reimplement merge_pairs using a whilte loop *)
xapp (>> Triple_ref Enc_loc null) ;=> p. (* LATER: spec auto *)

xapp. typeclass. (* LATER: inj by default *)
xapp (>> __ Enc_loc). (* LATEr: fix *)


Hint Extern 1 (_ \in _) => multiset_in.  ==> restrict to : multiset _

Mutable lists
=============

xapp (>> __ EA). (* LATER: resolve typeclass better *)

(* LATER:    length : using loop *)

. (* MListSeg_concat: using rewrite below existential binders, the proof would be far easier *)


* List segments : related to mlist
