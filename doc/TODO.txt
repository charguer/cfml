

TODO: xval tt


=========
=========
=========
LATER
Definition clear :=
    Set 'p'.data ':= ``nil '; (* TODO: ('nil%val)*)

LATER
   xfun_nosubst
   xfun S  // calls wp automatically


LATER: improve to use older technology
   Ltac xsimpl_lr_cancel_eq_repr_post tt :=
     try fequal; try reflexivity.

LATER: inj by default

(* LATER: if hsimpl fails to progress after xapp, warning *)


LATER: admitted in altproofs

=========
=========
=========


https://gitlab.inria.fr/charguer/cfml2_ejcp2019

Framework
=========


# Record
(* TODO:
   Set 'p '. X ':= ('p '.X '+ 1).
   won't parse
*)


# Record
Notation "'New'' `{ f1 := x1 ; f2 := x2 }" :=
   (Wptag (Wpgen_app (trm_apps (trm_val (val_record_init (f1::f2::nil)))) (trms_vals (x1::x2::nil))))
  (at level 0, f1 at level 0, f2 at level 0)
  : wp_scope.


# wp recursively computed for funs

# WPLoops

# WPArray

 ('p ':= '! (tail 'p)) '; (* LATER/ fix priority *)

 (If_ MList.is_empty ('q'.sub) (* LATER/ fix priority *)
   Then 'p ':= null
   Else 'p ':= merge_pairs ('q'.sub) )';
   'x.


Pairing heaps
=============

  (* LATER: reimplement merge_pairs using a whilte loop *)
xapp (>> Triple_ref Enc_loc null) ;=> p. (* LATER: spec auto *)

xapp. typeclass. (* LATER: inj by default *)
xapp (>> __ Enc_loc). (* LATEr: fix *)


Hint Extern 1 (_ \in _) => multiset_in.  ==> restrict to : multiset _

Mutable lists
=============

xapp (>> __ EA). (* LATER: resolve typeclass better *)

(* LATER:    length : using loop *)

. (* MListSeg_concat: using rewrite below existential binders, the proof would be far easier *)


* List segments : related to mlist
